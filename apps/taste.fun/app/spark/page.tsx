"use client";

import { useState, useEffect } from 'react';
import { ArrowLeft, Sparkles, AlertCircle, Loader2, Plus, Trash2 } from 'lucide-react';
import Link from 'next/link';
import { useRouter, useSearchParams } from 'next/navigation';
import { useConnection } from '@solana/wallet-adapter-react';
import { Card } from '@/components/ui/card';
import { CONSTANTS, lamportsToSol } from '@/lib/types/consensus-v3';
import { apiClient, type ThemeResponse } from '@/lib/api/client';
// import { createIdea } from '@/lib/anchor/instructions-v3';
// import { useAnchorProvider } from '@/lib/anchor/provider';

interface OptionConfig {
  id: string;
  label: string;
  prompt: string;
}

export default function SparkPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { connection } = useConnection();
  // const { program } = useAnchorProvider();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string>('');
  const [themes, setThemes] = useState<ThemeResponse[]>([]);
  const [loadingThemes, setLoadingThemes] = useState(true);
  const [aiLoading, setAiLoading] = useState(false);
  const [coverImage, setCoverImage] = useState<string>('');
  const [description, setDescription] = useState('');
  const [options, setOptions] = useState<OptionConfig[]>([
    { id: '1', label: '', prompt: '' },
    { id: '2', label: '', prompt: '' },
    { id: '3', label: '', prompt: '' },
    { id: '4', label: '', prompt: '' },
  ]);
  const [selectedModel, setSelectedModel] = useState('flux-1-schnell');
  const [formData, setFormData] = useState({
    prompt: '',
    votingDurationHours: 72,
    themeId: '',
  });

  // Image models configuration (video disabled as per requirements)
  const AVAILABLE_MODELS = [
    { id: 'flux-1-schnell', name: 'FLUX.1 Schnell', type: 'image', disabled: false },
    { id: 'stable-diffusion-xl-base-1.0', name: 'Stable Diffusion XL', type: 'image', disabled: false },
    { id: 'video-1', name: 'Video Generation (Coming Soon)', type: 'video', disabled: true }
  ];

  // Load available themes and pre-select from URL param
  useEffect(() => {
    const loadThemes = async () => {
      try {
        const response = await apiClient.getThemes({ status: 'Active' });
        setThemes(response.data);
        
        // Pre-select theme from URL parameter if provided
        const themeParam = searchParams.get('theme');
        if (themeParam) {
          const matchingTheme = response.data.find((t: ThemeResponse) => 
            t.id === themeParam || t.themeId.toString() === themeParam
          );
          if (matchingTheme) {
            setFormData(prev => ({ ...prev, themeId: matchingTheme.id }));
          }
        }
      } catch (err) {
        console.error('Failed to load themes:', err);
      } finally {
        setLoadingThemes(false);
      }
    };

    loadThemes();
  }, [searchParams]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    // Validation
    if (!formData.themeId) {
      setError('Please select a theme for your idea');
      return;
    }

    if (!description.trim()) {
      setError('Please enter a description for your idea');
      return;
    }

    if (!selectedModel) {
      setError('Please select a generation model');
      return;
    }

    if (!options.every(opt => opt.label.trim() && opt.prompt.trim())) {
      setError('Please fill in all option labels and prompts');
      return;
    }

    if (options.length < 2) {
      setError('Please add at least 2 voting options');
      return;
    }

    if (formData.votingDurationHours < 24 || formData.votingDurationHours > 168) {
      setError('Voting duration must be between 24 and 168 hours');
      return;
    }

    setIsSubmitting(true);

    try {
      // TODO: Integrate with backend API
      // 1. Create idea via API (includes all options and prompts)
      // 2. Backend will call smart contract createIdea
      // 3. Backend will trigger DePIN image generation with multiple prompts
      // 4. Backend will upload images to IPFS
      // 5. Backend will call smart contract confirmImages
      
      // For now, simulate the process
      console.log('Creating idea with options:', {
        themeId: formData.themeId,
        description,
        options,
        model: selectedModel,
        votingDurationHours: formData.votingDurationHours,
        coverImage,
      });
      
      // Simulate API call
      await new Promise((resolve) => setTimeout(resolve, 2000));
      
      alert(`Spark created successfully! 🎉

Theme: ${themes.find(t => t.id === formData.themeId)?.name}
Options: ${options.length}
Model: ${AVAILABLE_MODELS.find(m => m.id === selectedModel)?.name}

In production:
- Images will be generated by Cloudflare Worker AI
- Each option will get a unique image
- Voting will use theme tokens
- You'll receive real-time notifications`);
      
      // router.push(`/idea/${ideaPda.toString()}`);
      router.push('/');
    } catch (err: any) {
      console.error('Failed to create spark:', err);
      setError(err.message || 'Failed to create spark. Please try again.');
    } finally {
      setIsSubmitting(false);
    }
  };

  // Helper functions
  const addOption = () => {
    if (options.length >= 10) return;
    const newId = String(options.length + 1);
    setOptions([...options, { id: newId, label: '', prompt: '' }]);
  };

  const removeOption = (id: string) => {
    if (options.length <= 2) return;
    setOptions(options.filter(opt => opt.id !== id));
  };

  const updateOptionLabel = (id: string, label: string) => {
    setOptions(options.map(opt => opt.id === id ? { ...opt, label } : opt));
  };

  const updateOptionPrompt = (id: string, prompt: string) => {
    setOptions(options.map(opt => opt.id === id ? { ...opt, prompt } : opt));
  };

  const handleCoverFile = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e?.target?.files?.[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    setCoverImage(url);
  };

  // AI Assist Function
  const handleAIAssist = async () => {
    if (aiLoading || !description.trim()) return;
    
    setAiLoading(true);
    setError('');

    try {
      const AI_ENDPOINT = process.env.NEXT_PUBLIC_AI_ENDPOINT || 'https://buddy.cradleintro.top';
      const AI_PASSWORD = process.env.NEXT_PUBLIC_AI_PASSWORD;

      const response = await fetch(`${AI_ENDPOINT}/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${AI_PASSWORD}`
        },
        body: JSON.stringify({
          model: 'gemini-2.5-flash',
          messages: [
            {
              role: 'system',
              content: 'You are a helpful assistant that generates creative voting options with detailed image generation prompts. Return JSON only.'
            },
            {
              role: 'user',
              content: `Based on this idea description: "${description}", generate 4 creative voting options. 
              
              Return a JSON object with this exact format:
              {
                "options": [
                  { "label": "Option A Title", "prompt": "Detailed image generation prompt for option A" },
                  { "label": "Option B Title", "prompt": "Detailed image generation prompt for option B" },
                  { "label": "Option C Title", "prompt": "Detailed image generation prompt for option C" },
                  { "label": "Option D Title", "prompt": "Detailed image generation prompt for option D" }
                ]
              }
              
              Make each prompt 2-3 sentences, describing visual style, mood, colors, composition for AI image generation.`
            }
          ],
          response_format: { type: 'json_object' }
        })
      });

      if (!response.ok) {
        throw new Error(`AI request failed: ${response.status}`);
      }

      const result = await response.json();
      const content = JSON.parse(result.choices[0].message.content);
      
      if (content.options && Array.isArray(content.options)) {
        setOptions(content.options.map((opt: any, idx: number) => ({
          id: String(idx + 1),
          label: opt.label || '',
          prompt: opt.prompt || ''
        })));
      }
    } catch (err: any) {
      console.error('AI assist failed:', err);
      setError('AI assist failed. Please fill options manually.');
    } finally {
      setAiLoading(false);
    }
  };

  return (
    <div className="max-w-3xl mx-auto space-y-6">
      {/* Header */}
      <div className="flex items-center gap-4">
        <Link
          href="/"
          className="p-2 rounded-lg hover:bg-[var(--surface)] transition-colors"
        >
          <ArrowLeft size={20} />
        </Link>
        <div>
          <h1 className="text-2xl md:text-3xl font-bold text-white">Create a Spark</h1>
          <p className="text-zinc-400 text-sm mt-1">
            ✨ Taste & Earn: Submit a prompt, AI generates 4 images, community votes
          </p>
        </div>
      </div>

      {/* Info Banner */}
      <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4 flex gap-3">
        <Sparkles className="text-blue-400 flex-shrink-0 mt-0.5" size={20} />
        <div className="text-sm text-blue-200">
          <strong className="block mb-1">How Theme-Based Taste & Earn Works:</strong>
          <ol className="list-decimal list-inside space-y-1 text-blue-200/80">
            <li>Select a theme (each has its own token and voting rules)</li>
            <li>Submit an AI image generation prompt for that theme</li>
            <li>DePIN automatically generates 4 images (24h)</li>
            <li>Reviewers stake theme tokens to vote for the best image</li>
            <li>Winners split losers' 50% stake based on voting mode</li>
            <li>You receive 1% curator fee in tokens + winning NFT rights</li>
          </ol>
        </div>
      </div>

      {/* Form */}
      <form onSubmit={handleSubmit}>
        <Card>
          <Card.Content className="p-6 space-y-6">
            <h2 className="text-xl font-semibold text-white">
              Describe Your Vision
            </h2>

            {/* Theme Selection */}
            <div>
              <label className="block text-sm font-medium text-zinc-300 mb-2">
                Select Theme *
              </label>
              {loadingThemes ? (
                <div className="flex items-center gap-2 text-zinc-400 text-sm">
                  <Loader2 size={16} className="animate-spin" />
                  Loading themes...
                </div>
              ) : themes.length === 0 ? (
                <div className="bg-amber-500/10 border border-amber-500/30 rounded-lg p-4">
                  <p className="text-sm text-amber-200">
                    No active themes available. <Link href="/theme/create" className="underline">Create one first</Link>
                  </p>
                </div>
              ) : (
                <>
                  <select
                    value={formData.themeId}
                    onChange={(e) =>
                      setFormData({ ...formData, themeId: e.target.value })
                    }
                    className="w-full px-4 py-3 bg-zinc-900 border border-zinc-800 rounded-lg text-white focus:outline-none focus:border-[var(--brand)] focus:ring-1 focus:ring-[var(--brand)]"
                    required
                  >
                    <option value="">Choose a theme...</option>
                    {themes.map((theme) => (
                      <option key={theme.id} value={theme.id}>
                        {theme.name} ({theme.votingMode})
                      </option>
                    ))}
                  </select>
                  {formData.themeId && (
                    <div className="mt-2 p-3 bg-zinc-900/50 rounded-lg">
                      {(() => {
                        const selected = themes.find(t => t.id === formData.themeId);
                        if (!selected) return null;
                        return (
                          <div className="text-xs text-zinc-400 space-y-1">
                            <p><strong className="text-white">Description:</strong> {selected.description}</p>
                            <p><strong className="text-white">Voting Mode:</strong> {selected.votingMode}</p>
                            <p><strong className="text-white">Token Price:</strong> {selected.currentPrice.toFixed(9)} SOL</p>
                            <p><strong className="text-white">Ideas Created:</strong> {selected.totalIdeas || 0}</p>
                          </div>
                        );
                      })()}
                    </div>
                  )}
                </>
              )}
              <p className="text-xs text-zinc-500 mt-1">
                Voters will need this theme's tokens to participate
              </p>
            </div>

            {/* Model Selection */}
            <div>
              <label className="block text-sm font-medium text-zinc-300 mb-2">
                Generation Model *
              </label>
              <div className="grid grid-cols-3 gap-2">
                {AVAILABLE_MODELS.map((model) => (
                  <button
                    key={model.id}
                    type="button"
                    onClick={() => !model.disabled && setSelectedModel(model.id)}
                    disabled={model.disabled}
                    className={`relative py-3 px-4 rounded-lg text-sm font-medium transition-colors ${
                      selectedModel === model.id
                        ? 'bg-[var(--brand)] text-white'
                        : model.disabled
                        ? 'bg-zinc-800/50 text-zinc-600 cursor-not-allowed'
                        : 'bg-zinc-800 text-zinc-400 hover:text-white hover:bg-zinc-700'
                    }`}
                  >
                    {model.name}
                    {model.disabled && (
                      <span className="block text-xs mt-1 text-zinc-500">Coming Soon</span>
                    )}
                  </button>
                ))}
              </div>
              <p className="text-xs text-zinc-500 mt-2">
                Select an AI model for image generation
              </p>
            </div>

            {/* Cover Image Upload */}
            <div>
              <label className="block text-sm font-medium text-zinc-300 mb-2">
                Cover Image (Optional)
              </label>
              <div className="flex items-center gap-4">
                <div className="w-24 h-24 rounded-lg overflow-hidden bg-zinc-800 border border-zinc-700">
                  {coverImage ? (
                    <img src={coverImage} alt="Cover" className="w-full h-full object-cover" />
                  ) : (
                    <div className="w-full h-full flex items-center justify-center text-zinc-500 text-xs">
                      No image
                    </div>
                  )}
                </div>
                <div className="flex-1">
                  <p className="text-sm text-zinc-400 mb-2">
                    Upload a custom cover image for this idea
                  </p>
                  <div className="flex gap-2">
                    <label className="px-4 py-2 bg-zinc-800 rounded-lg cursor-pointer text-sm text-zinc-200 border border-zinc-700 hover:bg-zinc-700 transition-colors">
                      Upload Image
                      <input
                        type="file"
                        accept="image/*"
                        onChange={handleCoverFile}
                        className="hidden"
                      />
                    </label>
                    {coverImage && (
                      <button
                        type="button"
                        onClick={() => setCoverImage('')}
                        className="px-4 py-2 bg-transparent rounded-lg text-sm text-red-400 border border-zinc-700 hover:bg-red-400/10 transition-colors"
                      >
                        Clear
                      </button>
                    )}
                  </div>
                </div>
              </div>
            </div>

            {/* Idea Description with AI Assist */}
            <div>
              <div className="flex items-center justify-between mb-2">
                <label className="block text-sm font-medium text-zinc-300">
                  Idea Description *
                </label>
                <button
                  type="button"
                  onClick={handleAIAssist}
                  disabled={aiLoading || !description.trim()}
                  className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-xs font-medium transition-colors ${
                    aiLoading || !description.trim()
                      ? 'bg-zinc-800 text-zinc-500 cursor-not-allowed'
                      : 'bg-[var(--brand)]/20 hover:bg-[var(--brand)]/30 text-[var(--brand)]'
                  }`}
                >
                  {aiLoading ? (
                    <>
                      <Loader2 className="w-3 h-3 animate-spin" />
                      <span>Generating...</span>
                    </>
                  ) : (
                    <>
                      <Sparkles className="w-3 h-3" />
                      <span>AI Assist</span>
                    </>
                  )}
                </button>
              </div>
              <textarea
                rows={3}
                placeholder="Describe your voting idea... (e.g., 'Which flavor represents your life?')"
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                className="w-full px-4 py-3 bg-zinc-900 border border-zinc-800 rounded-lg text-white placeholder:text-zinc-600 focus:outline-none focus:border-[var(--brand)] focus:ring-1 focus:ring-[var(--brand)] resize-none"
                required
              />
              <p className="text-xs text-zinc-500 mt-1">
                💡 Describe your idea, then click "AI Assist" to auto-generate voting options and prompts
              </p>
            </div>

            {/* Voting Options Configuration */}
            <div>
              <div className="flex items-center justify-between mb-3">
                <label className="block text-sm font-medium text-zinc-300">
                  Voting Options *
                </label>
                <span className="text-xs text-zinc-500">
                  {options.length} options (min: 2, max: 10)
                </span>
              </div>
              
              <div className="space-y-3 mb-3">
                {options.map((option, index) => (
                  <div
                    key={option.id}
                    className="bg-zinc-900/50 rounded-lg p-4 border border-zinc-800"
                  >
                    <div className="flex items-start gap-3">
                      <div className="flex-shrink-0 w-8 h-8 rounded-full bg-zinc-800 flex items-center justify-center font-semibold text-sm">
                        {String.fromCharCode(65 + index)}
                      </div>
                      <div className="flex-1 space-y-2">
                        <input
                          type="text"
                          value={option.label}
                          onChange={(e) => updateOptionLabel(option.id, e.target.value)}
                          placeholder={`Option ${String.fromCharCode(65 + index)} label`}
                          className="w-full px-3 py-2 bg-zinc-800 border border-zinc-700 rounded-lg focus:outline-none focus:border-[var(--brand)] text-sm text-white"
                          required
                        />
                        <textarea
                          value={option.prompt}
                          onChange={(e) => updateOptionPrompt(option.id, e.target.value)}
                          placeholder="AI generation prompt for this option..."
                          rows={2}
                          className="w-full px-3 py-2 bg-zinc-800 border border-zinc-700 rounded-lg focus:outline-none focus:border-[var(--brand)] resize-none text-sm text-white"
                          required
                        />
                      </div>
                      {options.length > 2 && (
                        <button
                          type="button"
                          onClick={() => removeOption(option.id)}
                          className="flex-shrink-0 p-2 text-red-400 hover:bg-red-400/10 rounded-lg transition-colors"
                          title="Remove option"
                        >
                          <Trash2 className="w-4 h-4" />
                        </button>
                      )}
                    </div>
                  </div>
                ))}
              </div>

              {options.length < 10 && (
                <button
                  type="button"
                  onClick={addOption}
                  className="w-full py-2 border-2 border-dashed border-zinc-700 hover:border-[var(--brand)] rounded-lg transition-colors flex items-center justify-center gap-2 text-zinc-400 hover:text-white"
                >
                  <Plus className="w-4 h-4" />
                  Add Option
                </button>
              )}

              <p className="text-xs text-zinc-500 mt-2">
                💡 Each option will generate a unique image based on its prompt
              </p>
            </div>

            {/* Voting Duration */}
            <div>
              <label className="block text-sm font-medium text-zinc-300 mb-2">
                Voting Duration (Hours) *
              </label>
              <input
                type="number"
                min="24"
                max="168"
                value={formData.votingDurationHours}
                onChange={(e) =>
                  setFormData({
                    ...formData,
                    votingDurationHours: parseInt(e.target.value) || 72,
                  })
                }
                className="w-full px-4 py-3 bg-zinc-900 border border-zinc-800 rounded-lg text-white placeholder:text-zinc-600 focus:outline-none focus:border-[var(--brand)] focus:ring-1 focus:ring-[var(--brand)]"
                required
              />
              <p className="text-xs text-zinc-500 mt-1">
                Recommended: 72 hours (3 days). Min: 24h, Max: 168h (7 days)
              </p>
            </div>

            {/* Divider */}
            <div className="border-t border-zinc-800" />

            {/* Cost Summary */}
            <div className="bg-zinc-900/50 rounded-lg p-4 space-y-2">
              <h3 className="text-sm font-medium text-white mb-3">
                💰 Cost Breakdown
              </h3>
              <div className="flex justify-between text-sm">
                <span className="text-zinc-400">Creation Fee (non-refundable):</span>
                <span className="text-white font-medium">
                  {lamportsToSol(CONSTANTS.CREATION_FEE)} SOL
                </span>
              </div>
              <div className="flex justify-between text-sm">
                <span className="text-zinc-400">Transaction Fee (est.):</span>
                <span className="text-white font-medium">~0.00001 SOL</span>
              </div>
              <div className="pt-2 border-t border-zinc-800 flex justify-between text-sm">
                <span className="text-zinc-300 font-medium">Total:</span>
                <span className="text-[var(--brand)] font-bold">
                  ~{(lamportsToSol(CONSTANTS.CREATION_FEE) + 0.00001).toFixed(5)} SOL
                </span>
              </div>
            </div>

            {/* Earnings Info */}
            <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
              <h3 className="text-sm font-medium text-green-200 mb-2">
                📈 Your Potential Earnings
              </h3>
              <ul className="text-xs text-green-200/80 space-y-1">
                <li>
                  • <strong>1% Curator Fee</strong> from all theme token stakes (paid in tokens after voting)
                </li>
                <li>
                  • <strong>NFT Ownership</strong> of the winning image (future resale royalties)
                </li>
                <li>
                  • Example: If 50 people vote with 1000 tokens each, you earn 500 tokens instantly
                </li>
                <li>
                  • <strong>Token Buyback:</strong> 5% of voting proceeds are used to buy back and burn theme tokens
                </li>
              </ul>
            </div>

            {/* Error Message */}
            {error && (
              <div className="bg-red-500/10 border border-red-500/30 rounded-lg p-4 flex gap-3">
                <AlertCircle className="text-red-400 flex-shrink-0 mt-0.5" size={20} />
                <p className="text-sm text-red-200">{error}</p>
              </div>
            )}
          </Card.Content>
        </Card>

        {/* Action Buttons */}
        <div className="flex gap-3 justify-between mt-6">
          <Link
            href="/"
            className="px-6 py-3 rounded-lg border border-zinc-700 text-white hover:bg-zinc-800 transition-colors"
          >
            Cancel
          </Link>

          <button
            type="submit"
            disabled={isSubmitting}
            className="btn px-8 flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isSubmitting ? (
              <>
                <Loader2 size={16} className="animate-spin" />
                Creating...
              </>
            ) : (
              <>
                <Sparkles size={16} />
                Launch Spark 🚀
              </>
            )}
          </button>
        </div>
      </form>

      {/* Additional Info */}
      <div className="bg-amber-500/10 border border-amber-500/30 rounded-lg p-4">
        <h3 className="text-sm font-medium text-amber-200 mb-2">
          ⚠️ Anti-Sybil Protection (MVP Approach)
        </h3>
        <p className="text-xs text-amber-200/80">
          To prevent manipulation, each reviewer can stake max <strong>1 SOL per idea</strong>.
          This is a simple MVP solution. Future versions will use reputation-based weighting.
        </p>
      </div>
    </div>
  );
}
